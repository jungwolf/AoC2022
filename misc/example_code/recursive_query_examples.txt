------------------
try many options

drop table s_2_r;
create table s_2_r (groupno number, xline varchar2(4000));
insert into s_2_r values (1,'a:b');
insert into s_2_r values (2,'c:d');
commit;
select groupno,xline from s_2_r;

-- works with one line source
-- works with one line source
with t as (select groupno, xline, xline str from s_2_r where groupno=1)
select level as n, xline, regexp_substr(str,'[^:]+',1,level) as val
from   t
connect by regexp_substr(str,'[^:]+',1,level) is not null
/
1	a:b	a
2	a:b	b

-- doesn't work with two line source
with t as (select groupno, xline, xline str from s_2_r where groupno in (1,2))
select level as n, xline, regexp_substr(str,'[^:]+',1,level) as val
from   t
connect by regexp_substr(str,'[^:]+',1,level) is not null
/
n xline val
1	a:b	a
2	a:b	b
2	c:d	d
1	c:d	c
2	a:b	b
2	c:d	d
-- makes sense, there is no connection to restrict to the same groupno
-- 2 rows from level 1
-- 4 rows from level 2, a[bd] and c[bd]
-- I want the connection to level 2 restricted to the same groupno

-- the below, without nocycle, causes an error
-- ORA-01436: CONNECT BY loop in user data
select
  level as n
  , groupno
  , regexp_substr(str,'[^:]+',1,level) as val
  , str
  ,connect_by_root str
from   (
  select groupno, xline str from s_2_r where groupno in (1,2)
  )
--connect by regexp_substr(str,'[^:]+',1,level) is not null and groupno = prior groupno
connect by nocycle regexp_substr(str,'[^:]+',1,level) is not null and groupno = prior groupno
/
-- why does it error on a cycle when I add "groupno = prior groupno"?

-- start playing with advanced recursion
with t (str, rlevel)
  as (          select 'abc', 2 from dual
      union all select substr(str,rlevel), 2 from t
                where substr(str,rlevel) is not null
  )
select *
from t;
abc	2
bc	2
c	2

-- don't need rlevel
with t (str)
  as (          select 'abc' from dual
      union all select substr(str,2) from t
                where substr(str,2) is not null
  )
  --cycle str set is_cycle to 'Y' default 'N'
select *
from t;
abc
bc
c

-- works with two lines using substr()
with t (gno, l)
  as (          select groupno,xline from s_2_r --where rownum = 1
      union all select gno, substr(l,2) from t
                where substr(l,2) is not null
  )
select *
from t
order by gno, l;
1	:b
1	a:b
1	b
2	:d
2	c:d
2	d

-- finally works!!!
with t (gno, l, all_xline, levels)
  as (          select groupno,regexp_substr(xline,'[^:]+',1,1),xline, 1  from s_2_r --where rownum = 1
      union all select gno, regexp_substr(all_xline,'[^:]+',1,levels+1), all_xline, levels+1 from t
                where regexp_substr(all_xline,'[^:]+',1,levels+1) is not null
  )
select *
from t
order by gno, l;
1	a	a:b	1
1	b	a:b	2
2	c	c:d	1
2	d	c:d	2

-- more rows!
insert into s_2_r values (3,'bass:voies:oise');
insert into s_2_r values (4,'1:2:3:4:5:6:7');
1	a	a:b	1
1	b	a:b	2
2	c	c:d	1
2	d	c:d	2
3	bass	bass:voies:oise	1
3	oise	bass:voies:oise	3
3	voies	bass:voies:oise	2
4	1	1:2:3:4:5:6:7	1
4	2	1:2:3:4:5:6:7	2
4	3	1:2:3:4:5:6:7	3
4	4	1:2:3:4:5:6:7	4
4	5	1:2:3:4:5:6:7	5
4	6	1:2:3:4:5:6:7	6
4	7	1:2:3:4:5:6:7	7

/*
so what is going on? This is a recursive subquery. Recursive subqueries have two parts.

set 1- the original data to start
union all
set 2- the data generated by operating on set 1

Let's go through it line by line.

--with t (gno, l, all_xline, levels) as (
t -> subquery alias
(gno, l, all_xline, levels) -> column aliases used by the main query AND by the recursive part of this query

--select groupno, regexp_substr(xline,'[^:]+',1,1)           , xline    , 1        from s_2_r
The base dataset. The query can access all of the base table's columns.
The select columns are automatically given the alias from the "with t (...)" clause.
The number of columns must match.
It is basically a normal subquery with joins, where clauses, etc. Some limitations that you'll have to look up.

--union all select gno    , regexp_substr(all_xline,'[^:]+',1,levels+1), all_xline, levels+1 from t
--  where regexp_substr(all_xline,'[^:]+',1,levels+1) is not null
The recursive section uses the output from the base dataset. It can no longer access the base table.
It must reference the subquery name and use the defined column aliases. "t (gno, l, all_xline, levels)"
Every row from the base dataset is fed to this section to generate output. Hence "from t".
The output from this dataset is fed back into "t" to generate the next dataset.

The recursive section needs to end at some point. In this case the regex_substr() function eventually returns null.

**Option**
You can also/instead use a cycle clause.
It basically watches one or more columns to see if they repeat values.
If the values repeat, it is the end of that cycle and the row isn't returned to the recursive part.
--cycle {column_alias[,c_a...]} set {cycle_column_alias} to {cycle_yes} default {cycle_no}
Example:
--cycle emp_name, manager_name set is_cycle to 'Y' default 'N'
In this case it adds a new column is_cycle. The value is usually 'N'. It becomes 'Y' when it is the end of a cycle.
**End Option**

Usage notes:
The first clause should give all of the values needed to process the recursive clause.
For example column lvl as 1. Recursively set lvl to lvl+1. Tells you the recursive level.

*/
with t (gno, l, all_xline, levels) as (
            select groupno, regexp_substr(xline,'[^:]+',1,1)           , xline    , 1        from s_2_r
  union all select gno    , regexp_substr(all_xline,'[^:]+',1,levels+1), all_xline, levels+1 from t
              where regexp_substr(all_xline,'[^:]+',1,levels+1) is not null
  )
select *
from t
order by gno, l;

